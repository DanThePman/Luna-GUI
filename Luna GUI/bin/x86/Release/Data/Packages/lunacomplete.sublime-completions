{
"scope": "source.lua",

    "completions":
    [
{ "trigger": "func", "contents" : "function ${1:Funktionsname}()\n\nend" },
{ "trigger": "onupdate \t Zeichen- und Updatefunktion", "contents" : "function on.paint(gc --[[Grafikgerät]])\n\nend" },
{ "trigger": "onpaint \t Zeichen- und Updatefunktion", "contents" : "function on.paint(gc --[[Grafikgerät]])\n\nend" },
{ "trigger": "ontimer \t In Sekundenabständen vom timer aufgerufen", "contents" : "function on.timer()\n\nplatform.window:invalidate()\nend" },
{ "trigger": "oncharin \t Tritt ein sobald Buchstabe eingegeben wird", "contents" : "function on.paint(gc --[[Grafikgerät]])\n\nend" },
{ "trigger": "update \t Aktualisiert den Blildschirm", "contents" : "platform.window:invalidate()" },
{ "trigger": "onarrowRight \t Tritt ein wenn Pfeil nach rechts gedrückt wird", "contents" : "function on.arrowRight()\n\nend" },
{ "trigger": "onarrowLeft \t Tritt ein wenn Pfeil nach links gedrückt wird", "contents" : "function on.arrowLeft()\n\nend" },
{ "trigger": "onarrowUp \t Tritt ein wenn Pfeil nach oben gedrückt wird", "contents" : "function on.arrowUp()\n\nend" },
{ "trigger": "onarrowDown \t Tritt ein wenn Pfeil nach unten gedrückt wird", "contents" : "function on.arrowDown()\n\nend" },
{ "trigger": "onenterKey \t Tritt ein wenn ENTER gedrückt wird", "contents" : "function on.enterKey()\n\nend" },
{ "trigger": "onescapeKey \t Tritt ein wenn ESC gedrückt wird", "contents" : "function on.escapeKey()\n\nend" },
{ "trigger": "ontabKey \t Tritt ein ..Warum verwendest du überhaupt diese Funktion?!?", "contents" : "function on.tabKey()\n\nend" },
{ "trigger": "ondeleteKey", "contents" : "function on.deleteKey()\n\nend" },
{ "trigger": "onbackspaceKey", "contents" : "function on.backspaceKey()\n\nend" },
{ "trigger": "onreturnKey", "contents" : "function on.returnKey()\n\nend" },
{ "trigger": "onmousedown \t Tritt beim runterdrücken des Touchpads ein", "contents" : "function on.mouseDown()\n\nend" },
{ "trigger": "onmouseup \t Tritt beim loslassen des Touchpads ein", "contents" : "function on.mouseUp()\n\nend" },
{ "trigger": "onmousemove \t Tritt beim bewegen der Maus ein", "contents" : "function on.mouseMove()\n\nend" },
{ "trigger": "oncreate \t Tritt beim Scriptstart ein", "contents" : "function on.create()\n\nend" },
{ "trigger": "onactivate \t called when the focus is on the page (like launching the document, changing page etc...)", "contents" : "function on.activate()\n\nend" },
{ "trigger": "ondeactivate \t called when the focus is on the page (like launching the document, changing page etc...)", "contents" : "function on.activate()\n\nend" },
{ "trigger": "ondestroy \t Tritt beim schließen ein", "contents" : "function on.destroy()\n\nend" },
{ "trigger": "ongrabDown \t is called when the grabbing motion is detected", "contents" : "function on.grabDown()\n\nend" },
{ "trigger": "ongrabUp \t is called after the grabbing action", "contents" : "function on.grabUp()\n\nend" },

{ "trigger": "asset(Wert, Nachricht) \t Püft Wert, ob er wahr ist. Falls nicht, wird die Fehlermeldung ausgegeben", "contents" : "assert(${1:Wert}, ${2:Fehlermeldung})" },
{ "trigger": "collectgarbage() \t Gibt unbenutzen Arbeitsspeicher wieder frei", "contents" : "collectgarbage()\n" },
{ "trigger": "error(Fehlermeldung) \t Erschafft eine Fehlermeldung", "contents" : "error(${2:Fehlermeldung})" },
{ "trigger": "coroutine.create(1:function_name)", "contents" : "coroutine.create(${1:function_name})" },
{ "trigger": "coroutine.resume(function_name) \t waits for return val of coroutine again", "contents" : "coroutine.resume(${1:function_name})" },
{ "trigger": "coroutine.yield(returnVal)", "contents" : "coroutine.yield(${1:...})" },
{ "trigger": "tostring(Zahl) \t Konvertiert Zahl in Zeichenkette aka Text", "contents" : "tostring(${1:Zahl})" },
{ "trigger": "tonumber(Text) \t Konvertiert Text in Zahl", "contents" : "tonumber(${1:Text})" },
{ "trigger": "type(variable) \t Returns the type of variable as a string, 'number', 'string', 'table', 'function' or 'userdata'", "contents" : "type(${1:variable})" },
{ "trigger": "gc:clipRect(op, x, y, width, height)", "contents" : "gc:clipRect(op, x, y, width, height)" },
{ "trigger": "platform.window:invalidate() \t Screen update", "contents" : "platform.window:invalidate()" },
{ "trigger": "timer.start(Zeitintervall) \t Started timer and tickt alle X Sekunden", "contents" : "timer.start(${1:Zeitintervall})" },
{ "trigger": "gc:drawArc(x, y, width, height, start angle, finish angle)", "contents" : "gc:drawArc(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${4:angle0}, ${4:angle1})" },
{ "trigger": "gc:drawImage(image,x,y) \t-- Bitmap-basierend | no compression", "contents" : "gc:drawImage(image,x,y)" },
{ "trigger": "gc:drawLine(xstart, ystart, xend, yend) \t von P(xstart, ystart) nach P(xend, yend)", "contents" : "gc:drawLine(${1:xstart}, ${2:ystart}, ${3:xend}, ${4:yend})" },
{ "trigger": "gc:drawPolyLine(vertex_array) \t Bsp: {0,0, 0,100, 100,100..", "contents" : "c:drawPolyLine(${1:vertex_array})" },
{ "trigger": "gc:drawRect(x, y, width, height) \t Rechteck mit Punkten: [x|y|x+width|y+height],", "contents" : "gc:drawRect(${1:x}, ${2:y}, ${3:w}, ${4:h})" },
{ "trigger": "gc:drawString(Text, xKoordinate, yKoordinate, Position_Als_Text)", "contents" : "gc:drawString(${1:Text}, ${2:x}, ${3:y}, ${4:\"top\"}) " },
{ "trigger": "gc:setColorRGB(red, green, blue) \t RGB values are integers, from 0 to 255", "contents" : "gc:setColorRGB(${1:r}, ${2:g}, ${3:b})" },
{ "trigger": "gc:setFont(font, type, size) \t arial.. | type {“b”, “r”, “i”}, size(int)", "contents" : "gc:setFont(${1:font}, ${2:type}, ${3:size})" },
{ "trigger": "image.copy(theImage, width, height) \t Returns a copy of the input image scaled to fit the specified pixel width and height", "contents" : "image.copy(${1:theImage}, ${2:w}, ${3:h})" },
{ "trigger": "image.new(theImage) \t Allocates a new TI.Image", "contents" : "image.new(${1:theImage})" },
{ "trigger": "image.rotate(theImage, angle)", "contents" : "image.rotate(${1:theImage}, ${2:angle})" },

"platform.isColorDisplay()",
"platform.isDeviceModeRendering()",
"platform.window",
"platform.hw()",

"timer.stop()",

{ "trigger": "register(menuStructure)", "contents" : "register(${1:menuStructure})" },
{ "trigger": "enable(toolname, itemname, state)", "contents" : "enable(${1:toolname}, ${2:itemname}, ${3:state})" },

"cursor.hide()",
"cursor.show()",
{ "trigger": "cursor.set(cursorname)", "contents" : "cursor.set(${1:cursorname})" },

"document.markChanged()",


{ "trigger": "math.evalStr(Problem) \t Führt Rechenbefehl aus, der als string angegeben ist", "contents" : "math.evalStr(${1:string})" },
{ "trigger": "math.setEvalSettings() \t Legt Recheneinstellungen für den Taschenrechner fest", "contents" : "math.evalStr(${1:string})" },



/*pragma region Simplyfied syntax*/
{ "trigger": "Leer", "contents" : "nil" },

{ "trigger": "Variable", "contents" : "local ${1:Name} = ${2:nil}" },
{ "trigger": "Funktion", "contents" : "function ${1:Funktionsname}()\n\nend" },
{ "trigger": "Liste", "contents" : "local ${1:Name} = { ${2:Element1}, ${3:Element2}, ${4:Element3}}" },
{ "trigger": "Zahl_Als_Text", "contents" : "tostring(${1:Zahl})" },
{ "trigger": "Text_Als_Zahl", "contents" : "tonumber(${1:Text})" },
{ "trigger": "Schreibe", "contents" : "gc:drawString(${1:Text}, ${2:x_Koordinate}, ${3:y_Koordinate}, \"top\")" },


{ "trigger": "Gleich", "contents" : "==" },
{ "trigger": "Ungleich", "contents" : "~=" },
{ "trigger": "Größer", "contents" : ">" },
{ "trigger": "Kleiner", "contents" : "<" },
{ "trigger": "GößerGleich", "contents" : ">=" },
{ "trigger": "KleinerGleich", "contents" : "<=" },


{ "trigger": "nicht", "contents" : "not" },
{ "trigger": "und", "contents" : "and" },
{ "trigger": "oder", "contents" : "or" },

// IF ETC DECLARED IN SNIPPETS
//{ "trigger": "_FallsLeer", "if\n${1:Variable}\nthen\nend" },
//{"trigger": "_Falls", "contents" : "if ${1:Bedingung} ${2:BedingungsOperator} ${3:Wert} then\n${4:else}\nend"},

/*pragma endregion Simplyfied syntax*/

    ]
}